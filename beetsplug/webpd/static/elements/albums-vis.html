<link rel="import" href="../bower_components/polymer/polymer.html">

<polymer-element name="albums-vis" attributes="albums">
<template>
  <style>
    albums-vis ^ #render {
      width: 100%;
      height: 100%;
    }
  </style>
  <svg id="render"></svg>
</template>
<script>
/**
 * Small-multiples style parallel visualization of a collection of albums in
 * a horizontally oriented style for use in a scrolling artist list.
 *
 * ## Scales ##
 * 
 * Because we are expecting to have a bunch of siblings that are also created
 * independently, all coordinate spaces are based on reasonable hard-coded
 * ranges with gutters left over for outliers.  While specific ranges may vary
 * based on the music database, a few ranges likely work.  For example, there's
 * a good chance you only care about music before 1950 if you are big into
 * classical music and are using the year of composition.  Likewise, we do not
 * particularly need extremely low or high BPM's to be displayed.
 *
 * ## Display Strategy ##
 *
 * Heatmaps using sparse bins.
 *
 */
Polymer('albums-vis', {
  albums: null,
  
  ready: function() {
    this.render();
  },
  albumsChanged: function() {
    this.render();
  },
  render: function() {
    if (!this.albums) {
      return;
    }

    var svg = d3.select(this.$.render);

    var padding = 0;

    var width = parseInt(svg.style("width")) - padding;
    var height = parseInt(svg.style("height")) - padding;

    var curYear = new Date().getUTCFullYear();
    var FIRST_YEAR = 1979;
    var LAST_YEAR = curYear;

    var numYearBuckets = LAST_YEAR - FIRST_YEAR + 1;
    var yearWidth = Math.floor(width / numYearBuckets);
    // create an x-scale that maps from year to the starting x coordinate of the
    // year bin.  We need to subtract one bucket's worth of width back off to
    // make this happen without random stretch gaps.
    var xTime = d3.scale.linear()
      .domain([FIRST_YEAR, LAST_YEAR])
      .rangeRound([0, yearWidth * (numYearBuckets - 1)])
      .clamp(true);

    var rectHeight = Math.floor(height / 3);

    function normalizeYear(album) {
      var year = album.get('year') || FIRST_YEAR;
      if (year < FIRST_YEAR) year = FIRST_YEAR;
      if (year > LAST_YEAR) year = LAST_YEAR;
      return year;
    }

    function renderAlbums(type, albums, rowNum, useColor, fullColorAtCount) {
      // May intentionally be undefined for simplicity for missing types
      if (!albums) {
        return;
      }

      var yearBins = d3.nest()
        .key(normalizeYear)
        .entries(albums);

      var color = d3.scale.linear()
        .domain([0, fullColorAtCount])
        .range(['white', useColor])
        .clamp(true);

      var className = type + '-year';
      var heatRects = svg.selectAll('.' + className)
          .data(yearBins)
        .enter().append('rect')
          .attr('class', className)
          .attr('width', yearWidth)
          .attr('height', rectHeight)
          .attr('x', function(bin) { return xTime(parseInt(bin.key, 10)); })
          .attr('y', rowNum * rectHeight)
          .attr('fill', function(bin) { return color(bin.values.length); })
    }

    var albumsByType = this.albums.groupBy('normalbumtype');
    // color-wise, we should probably just be varying the opacity rather than
    // interpolating the color so that CSS could handle the color.
    renderAlbums('album', albumsByType.album, 0, 'red', 6);
    renderAlbums('single', albumsByType.single, 1, 'green', 6);
    renderAlbums('compilation', albumsByType.compilation, 2, 'blue', 6);
  }
});
</script>
</polymer-element>
